

;
; ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
; บ	This file is generated by The Interactive Disassembler (IDA)	    บ
; บ	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    บ
; บ			 Licensed to: Freeware version			    บ
; ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
;
; Input	MD5   :	BBF30DB4E8DB21202F3C1B7836A8D545

; File Name   :	Z:\home\g\Juegos\the-scoop-re\dos\CODE.EXE
; Format      :	MS-DOS executable (EXE)
; Base Address:	0h Range: 0h-2860h Loaded length: 205Dh
; Entry	Point :	2B:12

.386
.model large


; Segment type:	Pure code
seg000 segment byte public 'CODE' use16
assume cs:seg000
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing



sub_0 proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
mov	ax, 15Ch
push	ds
push	ax
call	sub_1460
add	sp, 6
retf
sub_0 endp




sub_18 proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
mov	ax, 166h
push	ds
push	ax
call	sub_1482
add	sp, 6
retf
sub_18 endp




sub_30 proc far
xor	ax, ax
call	sub_51C
mov	ax, 400h
cwd
push	dx
push	ax
mov	ax, 1
push	ax
call	sub_DF6
add	sp, 6
retf
sub_30 endp




sub_4A proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_86E
add	sp, 2
retf
sub_4A endp




sub_5E proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
mov	ax, 170h
push	ds
push	ax
call	sub_D44
add	sp, 6
retf
sub_5E endp




sub_76 proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_F82
add	sp, 2
retf
sub_76 endp




sub_8A proc far
xor	ax, ax
call	sub_51C
mov	ax, 2
push	ax
mov	ax, 1
push	ax
call	sub_FBA
add	sp, 4
retf
sub_8A endp




sub_A2 proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_D60
add	sp, 2
retf
sub_A2 endp




sub_B6 proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	far ptr	sub_454
add	sp, 2
retf
sub_B6 endp




sub_CA proc far
xor	ax, ax
call	sub_51C
call	sub_CFE
retf
sub_CA endp

align 2



sub_D8 proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_FE2
add	sp, 2
retf
sub_D8 endp




sub_EC proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_D20
add	sp, 2
retf
sub_EC endp




sub_100	proc far
xor	ax, ax
call	sub_51C
mov	ax, 400h
cwd
push	dx
push	ax
sub	ax, ax
push	ax
mov	ax, 1
push	ax
call	sub_14CC
add	sp, 8
retf
sub_100	endp

align 2



sub_11E	proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
push	ax
push	ax
mov	ax, 1
push	ax
call	far ptr	sub_88E
add	sp, 8
retf
sub_11E	endp

align 2


; Attributes: bp-based frame

sub_138	proc far

var_A= word ptr	-0Ah

push	bp
mov	bp, sp
mov	ax, 0Ah
call	sub_51C
lea	ax, [bp+var_A]
push	ss
push	ax
call	sub_104A
mov	sp, bp
pop	bp
retf
sub_138	endp

align 2



sub_152	proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
mov	ax, 17Ch
push	ds
push	ax
call	sub_908
add	sp, 6
retf
sub_152	endp



; Attributes: bp-based frame

sub_16A	proc far

var_64=	word ptr -64h

push	bp
mov	bp, sp
mov	ax, 64h	; 'd'
call	sub_51C
mov	ax, 64h	; 'd'
push	ax
lea	ax, [bp+var_64]
push	ss
push	ax
mov	ax, 1
push	ax
call	sub_AB8
mov	sp, bp
pop	bp
retf
sub_16A	endp

align 2


; Attributes: bp-based frame

sub_18C	proc far

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
mov	ax, 4
call	sub_51C
mov	[bp+var_4], 5678h
mov	[bp+var_2], 1234h
mov	ax, 5678h
mov	dx, 1234h
push	dx
push	ax
call	sub_1586
mov	sp, bp
pop	bp
retf
sub_18C	endp




sub_1B2	proc far
xor	ax, ax
call	sub_51C
mov	ax, 18Ah
push	ds
push	ax
mov	ax, 196h
push	ds
push	ax
call	sub_1572
add	sp, 8
retf
sub_1B2	endp




sub_1CC	proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
mov	ax, 1
push	ax
call	sub_1128
add	sp, 4
retf
sub_1CC	endp

align 2



sub_1E4	proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
push	ax
mov	ax, 1A2h
push	ds
push	ax
call	sub_DC2
add	sp, 8
retf
sub_1E4	endp

align 2



sub_1FE	proc far
xor	ax, ax
call	sub_51C
mov	ax, 1
push	ax
call	sub_DDE
add	sp, 2
retf
sub_1FE	endp




sub_212	proc far
xor	ax, ax
call	sub_51C
sub	ax, ax
push	ax
call	sub_144E
add	sp, 2
retf
sub_212	endp

align 2


; Attributes: bp-based frame

sub_226	proc far

var_A= word ptr	-0Ah

push	bp
mov	bp, sp
mov	ax, 0Ah
call	sub_51C
mov	ax, 5
push	ax
lea	ax, [bp+var_A]
push	ss
push	ax
mov	ax, 1
push	ax
call	sub_BA0
mov	sp, bp
pop	bp
retf
sub_226	endp

align 2



sub_248	proc far
xor	ax, ax
call	sub_51C
push	cs
call	near ptr sub_0
push	cs
call	near ptr sub_18
push	cs
call	near ptr sub_30
push	cs
call	near ptr sub_4A
push	cs
call	near ptr sub_5E
push	cs
call	near ptr sub_76
push	cs
call	near ptr sub_8A
push	cs
call	near ptr sub_A2
push	cs
call	near ptr sub_D8
push	cs
call	near ptr sub_EC
push	cs
call	near ptr sub_100
push	cs
call	near ptr sub_11E
push	cs
call	near ptr sub_138
push	cs
call	near ptr sub_152
push	cs
call	near ptr sub_16A
push	cs
call	near ptr sub_18C
push	cs
call	near ptr sub_1B2
push	cs
call	near ptr sub_1CC
push	cs
call	near ptr sub_1E4
push	cs
call	near ptr sub_1FE
push	cs
call	near ptr sub_212
push	cs
call	near ptr sub_226
push	cs
call	near ptr sub_B6
push	cs
call	near ptr sub_CA
sub	ax, ax
retf
sub_248	endp

seg000 ends


; Segment type:	Pure code
seg001 segment byte public 'CODE' use16
assume cs:seg001
;org 2
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
db 10h dup(0)
assume ss:seg003, ds:nothing



public start
start proc near
mov	ah, 30h
int	21h		; DOS -	GET DOS	VERSION
			; Return: AL = major version number (00h for DOS 1.x)
cmp	al, 2
jnb	short loc_2CC
int	20h		; DOS -	PROGRAM	TERMINATION
			; returns to DOS--identical to INT 21/AH=00h

loc_2CC:
mov	di, seg	dseg
mov	si, ds:2
sub	si, di
cmp	si, 1000h
jb	short loc_2DE
mov	si, 1000h

loc_2DE:
cli
mov	ss, di
assume ss:dseg
add	sp, 2BEh
sti
jnb	short loc_2FC
push	ss
pop	ds
assume ds:dseg
call	sub_4F2
xor	ax, ax
push	ax
call	sub_7AD
mov	ax, 4CFFh
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
			; AL = exit code

loc_2FC:
and	sp, 0FFFEh
mov	ss:word_1DE8, sp
mov	ss:word_1DE4, sp
mov	ax, si
mov	cl, 4
shl	ax, cl
dec	ax
mov	ss:word_1DE2, ax
add	si, di
mov	word_1DA2, si
mov	bx, es
sub	bx, si
neg	bx
mov	ah, 4Ah
int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
mov	ss:word_1E59, ds
push	ss
pop	es
assume es:dseg
cld
mov	di, 2BEh
mov	cx, 2C0h
sub	cx, di
xor	ax, ax
rep stosb
push	ss
pop	ds
call	sub_390
push	ss
pop	ds
call	sub_70E
call	far ptr	sub_566
xor	bp, bp
push	word_1E7E
push	word_1E7C
push	word_1E7A
push	word_1E78
push	word_1E76
call	sub_248
push	ax
call	far ptr	sub_454
mov	ax, seg	dseg
mov	ds, ax
mov	ax, 3
mov	ss:off_1DE6, 1A4h

loc_37C:
push	ax
call	sub_4F2
call	sub_7AD
mov	ax, 0FFh
push	ax
push	cs
call	off_1DE6
start endp




sub_390	proc far

; FUNCTION CHUNK AT 0266 SIZE 00000006 BYTES

mov	ah, 30h
int	21h		; DOS -	GET DOS	VERSION
			; Return: AL = major version number (00h for DOS 1.x)
mov	word_1E5B, ax
mov	ax, 3500h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	word ptr dword_1E47, bx
mov	word ptr dword_1E47+2, es
push	cs
pop	ds
assume ds:seg001
mov	ax, 2500h
mov	dx, 0BDh ; 'ฝ'
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
push	ss
pop	ds
assume ds:dseg
mov	cx, word ptr dword_1EF0+2
jcxz	short loc_3E4
mov	es, word_1E59
assume es:nothing
mov	si, es:2Ch
lds	ax, dword_1EF4
mov	dx, ds
xor	bx, bx
call	ss:dword_1EF0
jnb	short loc_3D3
push	ss
pop	ds
jmp	loc_516

loc_3D3:
lds	ax, ss:dword_1EF8
mov	dx, ds
mov	bx, 3
call	ss:dword_1EF0
push	ss
pop	ds

loc_3E4:
mov	es, word_1E59
mov	cx, es:2Ch
jcxz	short loc_425
mov	es, cx
xor	di, di

loc_3F3:
cmp	byte ptr es:[di], 0
jz	short loc_425
mov	cx, 0Ch
mov	si, 9Ah	; ''
repe cmpsb
jz	short loc_40E
mov	cx, 7FFFh
xor	ax, ax
repne scasb
jnz	short loc_425
jmp	short loc_3F3

loc_40E:
push	es
push	ds
pop	es
assume es:dseg
pop	ds
mov	si, di
mov	di, 0C2h ; 'ย'
lodsb
cbw
xchg	ax, cx

loc_41A:
lodsb
inc	al
jz	short loc_420
dec	ax

loc_420:
stosb
loop	loc_41A
push	ss
pop	ds

loc_425:
mov	bx, 4

loc_428:
and	byte ptr [bx+0C2h], 0BFh
mov	ax, 4400h
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
jb	short loc_43E
test	dl, 80h
jz	short loc_43E
or	byte ptr [bx+0C2h], 40h

loc_43E:
dec	bx
jns	short loc_428
mov	si, 15Ch
mov	di, 15Ch
call	sub_4DF
mov	si, 15Ch
mov	di, 15Ch
call	sub_4DF
retf
sub_390	endp



; Attributes: bp-based frame

sub_454	proc near
push	bp
mov	bp, sp
mov	si, 2BEh
mov	di, 2BEh
call	sub_4DF
mov	si, 15Ch
mov	di, 15Ch
call	sub_4DF
jmp	short loc_46E
sub_454	endp



; Attributes: bp-based frame

sub_46B	proc near

arg_2= word ptr	 6

push	bp
mov	bp, sp

loc_46E:
mov	si, 15Ch
mov	di, 15Ch
call	sub_4DF
mov	si, 15Ch
mov	di, 15Ch
call	sub_4DF
call	sub_540
or	ax, ax
jz	short loc_494
cmp	[bp+arg_2], 0
jnz	short loc_494
mov	[bp+arg_2], 0FFh

loc_494:
mov	cx, 0Fh
mov	bx, 5

loc_49A:
test	byte ptr [bx+0C2h], 1
jz	short loc_4A5
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle

loc_4A5:
inc	bx
loop	loc_49A
call	sub_4B2
mov	ax, [bp+arg_2]
mov	ah, 4Ch
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
sub_46B	endp		; AL = exit code




sub_4B2	proc near
mov	cx, word ptr dword_1EF0+2
jcxz	short loc_4BF
mov	bx, 2
call	dword_1EF0

loc_4BF:
push	ds
lds	dx, dword_1E47
mov	ax, 2500h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
cmp	byte_1E88, 0
jz	short locret_4DE
push	ds
mov	al, byte_1E89
lds	dx, dword_1E8A
mov	ah, 25h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds

locret_4DE:
retn
sub_4B2	endp




sub_4DF	proc near
cmp	si, di
jnb	short locret_4F1
sub	di, 4
mov	ax, [di]
or	ax, [di+2]
jz	short sub_4DF
call	dword ptr [di]
jmp	short sub_4DF

locret_4F1:
retn
sub_4DF	endp



; Attributes: bp-based frame

sub_4F2	proc far
push	bp
mov	bp, sp
mov	ax, 0FCh ; ''
push	ax
call	sub_7AD
cmp	word_1E90, 0
jz	short loc_509
call	dword ptr unk_1E8E

loc_509:
mov	ax, 0FFh
push	ax
call	sub_7AD
mov	sp, bp
pop	bp
retf
sub_4F2	endp

; START	OF FUNCTION CHUNK FOR sub_390

loc_516:
mov	ax, 2
jmp	loc_37C
; END OF FUNCTION CHUNK	FOR sub_390



sub_51C	proc far
pop	cx
pop	dx
mov	bx, sp
sub	bx, ax
jb	short loc_52F
cmp	bx, word_1E96
jb	short loc_52F
mov	sp, bx
push	dx
push	cx
retf

loc_52F:
mov	ax, word ptr dword_1E92
inc	ax
jnz	short loc_53A
xor	ax, ax
jmp	loc_37C

loc_53A:
push	dx
push	cx
jmp	dword_1E92
sub_51C	endp




sub_540	proc far
push	si
xor	si, si
mov	cx, 42h	; 'B'
xor	ah, ah
cld

loc_549:
lodsb
xor	ah, al
loop	loc_549
xor	ah, 55h
jz	short loc_564
call	sub_4F2
mov	ax, 1
push	ax
call	sub_7AD
mov	ax, 1

loc_564:
pop	si
retf
sub_540	endp




sub_566	proc near
pop	word ptr dword_1E98
pop	word ptr dword_1E98+2
mov	dx, 2
cmp	byte ptr word_1E5B, dl
jz	short loc_5A0
mov	es, word_1E59
assume es:nothing
mov	es, word ptr es:2Ch
mov	seg_1E82, es
xor	ax, ax
cwd
mov	cx, 8000h
xor	di, di

loc_58C:
repne scasb
scasb
jnz	short loc_58C
inc	di
inc	di
mov	word_1E80, di
mov	cx, 0FFFFh
repne scasb
not	cx
mov	dx, cx

loc_5A0:
mov	di, 1
mov	si, 81h	; ''
mov	ds, word_1E59

loc_5AA:
lodsb
cmp	al, 20h	; ' '
jz	short loc_5AA
cmp	al, 9
jz	short loc_5AA
cmp	al, 0Dh
jz	short loc_626
or	al, al
jz	short loc_626
inc	di

loc_5BC:
dec	si

loc_5BD:
lodsb
cmp	al, 20h	; ' '
jz	short loc_5AA
cmp	al, 9
jz	short loc_5AA
cmp	al, 0Dh
jz	short loc_626
or	al, al
jz	short loc_626
cmp	al, 22h	; '"'
jz	short loc_5F6
cmp	al, 5Ch	; '\'
jz	short loc_5D9
inc	dx
jmp	short loc_5BD

loc_5D9:
xor	cx, cx

loc_5DB:
inc	cx
lodsb
cmp	al, 5Ch	; '\'
jz	short loc_5DB
cmp	al, 22h	; '"'
jz	short loc_5E9
add	dx, cx
jmp	short loc_5BC

loc_5E9:
mov	ax, cx
shr	cx, 1
adc	dx, cx
test	al, 1
jnz	short loc_5BD
jmp	short loc_5F6

loc_5F5:
dec	si

loc_5F6:
lodsb
cmp	al, 0Dh
jz	short loc_626
or	al, al
jz	short loc_626
cmp	al, 22h	; '"'
jz	short loc_5BD
cmp	al, 5Ch	; '\'
jz	short loc_60A
inc	dx
jmp	short loc_5F6

loc_60A:
xor	cx, cx

loc_60C:
inc	cx
lodsb
cmp	al, 5Ch	; '\'
jz	short loc_60C
cmp	al, 22h	; '"'
jz	short loc_61A
add	dx, cx
jmp	short loc_5F5

loc_61A:
mov	ax, cx
shr	cx, 1
adc	dx, cx
test	al, 1
jnz	short loc_5F6
jmp	short loc_5BD

loc_626:
push	ss
pop	ds
mov	word_1E76, di
add	dx, di
inc	di
shl	di, 1
shl	di, 1
add	dx, di
and	dl, 0FEh
sub	sp, dx
mov	ax, sp
mov	word_1E78, ax
mov	word_1E7A, ds
mov	bx, ax
add	di, bx
push	ss
pop	es
assume es:dseg
mov	ss:[bx], di
mov	word ptr ss:[bx+2], ss
add	bx, 4
lds	si, dword ptr word_1E80

loc_657:
lodsb
stosb
or	al, al
jnz	short loc_657
mov	si, 81h	; ''
mov	ds, ss:word_1E59
jmp	short loc_66A

loc_667:
xor	ax, ax
stosb

loc_66A:
lodsb
cmp	al, 20h	; ' '
jz	short loc_66A
cmp	al, 9
jz	short loc_66A
cmp	al, 0Dh
jnz	short loc_67A
jmp	loc_6FE

loc_67A:
or	al, al
jnz	short loc_681
jmp	short loc_6FE
db 90h

loc_681:
mov	ss:[bx], di
mov	word ptr ss:[bx+2], ss
add	bx, 4

loc_68B:
dec	si

loc_68C:
lodsb
cmp	al, 20h	; ' '
jz	short loc_667
cmp	al, 9
jz	short loc_667
cmp	al, 0Dh
jz	short loc_6FB
or	al, al
jz	short loc_6FB
cmp	al, 22h	; '"'
jz	short loc_6C8
cmp	al, 5Ch	; '\'
jz	short loc_6A8
stosb
jmp	short loc_68C

loc_6A8:
xor	cx, cx

loc_6AA:
inc	cx
lodsb
cmp	al, 5Ch	; '\'
jz	short loc_6AA
cmp	al, 22h	; '"'
jz	short loc_6BA
mov	al, 5Ch	; '\'
rep stosb
jmp	short loc_68B

loc_6BA:
mov	al, 5Ch	; '\'
shr	cx, 1
rep stosb
jnb	short loc_6C8
mov	al, 22h	; '"'
stosb
jmp	short loc_68C

loc_6C7:
dec	si

loc_6C8:
lodsb
cmp	al, 0Dh
jz	short loc_6FB
or	al, al
jz	short loc_6FB
cmp	al, 22h	; '"'
jz	short loc_68C
cmp	al, 5Ch	; '\'
jz	short loc_6DC
stosb
jmp	short loc_6C8

loc_6DC:
xor	cx, cx

loc_6DE:
inc	cx
lodsb
cmp	al, 5Ch	; '\'
jz	short loc_6DE
cmp	al, 22h	; '"'
jz	short loc_6EE
mov	al, 5Ch	; '\'
rep stosb
jmp	short loc_6C7

loc_6EE:
mov	al, 5Ch	; '\'
shr	cx, 1
rep stosb
jnb	short loc_68C
mov	al, 22h	; '"'
stosb
jmp	short loc_6C8

loc_6FB:
xor	ax, ax
stosb

loc_6FE:
push	ss
pop	ds
mov	word ptr [bx], 0
mov	word ptr [bx+2], 0
jmp	dword_1E98
sub_566	endp

align 2


; Attributes: bp-based frame

sub_70E	proc far
push	bp
mov	bp, sp
push	bp
mov	ds, word_1E59
xor	cx, cx
mov	ax, cx
mov	bp, cx
mov	di, cx
dec	cx
mov	si, word_1DCC
or	si, si
jz	short loc_72F
mov	es, si
assume es:nothing

loc_729:
repne scasb
inc	bp
scasb
jnz	short loc_729

loc_72F:
inc	bp
xchg	ax, di
inc	ax
and	al, 0FEh
mov	di, bp
shl	bp, 1
shl	bp, 1
add	ax, bp
push	ss
pop	ds
push	di
mov	di, 9
call	sub_7D8
pop	di
mov	cx, di
mov	di, bp
add	di, ax
mov	word_1E7C, bp
mov	word_1E7E, ds
push	ds
pop	es
assume es:dseg
mov	ds, si
xor	si, si
dec	cx
jcxz	short loc_774

loc_75D:
cmp	word ptr [si], 433Bh
jz	short loc_76C
mov	[bp+0],	di
mov	word ptr [bp+2], es
add	bp, 4

loc_76C:
lodsb
stosb
or	al, al
jnz	short loc_76C
loop	loc_75D

loc_774:
mov	[bp+0],	cx
mov	[bp+2],	cx
push	ss
pop	ds
pop	bp
mov	sp, bp
pop	bp
retf
sub_70E	endp

align 2


; Attributes: bp-based frame

sub_782	proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di
push	ds
pop	es
mov	dx, [bp+arg_0]
mov	si, 1BAh

loc_78F:
lodsw
cmp	ax, dx
jz	short loc_7A4
inc	ax
xchg	ax, si
jz	short loc_7A4
xchg	ax, di
xor	ax, ax
mov	cx, 0FFFFh
repne scasb
mov	si, di
jmp	short loc_78F

loc_7A4:
xchg	ax, si
pop	di
pop	si
mov	sp, bp
pop	bp
retf	2
sub_782	endp



; Attributes: bp-based frame

sub_7AD	proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	di
push	[bp+arg_0]
call	sub_782
or	ax, ax
jz	short loc_7D1
xchg	ax, dx
mov	di, dx
xor	ax, ax
mov	cx, 0FFFFh
repne scasb
not	cx
dec	cx
mov	bx, 2
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

loc_7D1:
pop	di
mov	sp, bp
pop	bp
retf	2
sub_7AD	endp




sub_7D8	proc near
mov	dx, ax
add	ax, word_1DE8
jb	short loc_815
cmp	word_1DE2, ax
jnb	short loc_80B
add	ax, 0Fh
push	ax
rcr	ax, 1
mov	cl, 3
shr	ax, cl
mov	cx, ds
mov	bx, word_1E59
sub	cx, bx
add	ax, cx
mov	es, bx
assume es:nothing
mov	bx, ax
mov	ah, 4Ah
int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
pop	ax
jb	short loc_815
and	al, 0F0h
dec	ax
mov	word_1DE2, ax

loc_80B:
xchg	ax, bp
mov	bp, word_1DE8
add	word_1DE8, dx
retn

loc_815:
mov	ax, di
jmp	loc_37C
sub_7D8	endp

; START	OF FUNCTION CHUNK FOR sub_86E

loc_81A:
jb	short loc_82F

loc_81C:
xor	ax, ax
mov	sp, bp
pop	bp
retf
; END OF FUNCTION CHUNK	FOR sub_86E
jnb	short loc_81C
push	ax
call	sub_840
pop	ax
mov	sp, bp
pop	bp
retf
; START	OF FUNCTION CHUNK FOR sub_908

loc_82D:
jnb	short loc_836
; END OF FUNCTION CHUNK	FOR sub_908
; START	OF FUNCTION CHUNK FOR sub_86E

loc_82F:
call	sub_840
mov	ax, 0FFFFh
cwd

loc_836:
mov	sp, bp
pop	bp
retf
; END OF FUNCTION CHUNK	FOR sub_86E



sub_83A	proc far
xor	ah, ah
call	sub_840
retf
sub_83A	endp




sub_840	proc near
mov	byte ptr word_1E5E, al
or	ah, ah
jnz	short loc_86A
cmp	byte ptr word_1E5B, 3
jb	short loc_85B
cmp	al, 22h	; '"'
jnb	short loc_85F
cmp	al, 20h	; ' '
jb	short loc_85B
mov	al, 5
jmp	short loc_861
db 90h

loc_85B:
cmp	al, 13h
jbe	short loc_861

loc_85F:
mov	al, 13h

loc_861:
mov	bx, 0FCh ; ''
xlat

loc_865:
cbw
mov	word_1E53, ax
retn

loc_86A:
mov	al, ah
jmp	short loc_865
sub_840	endp



; Attributes: bp-based frame

sub_86E	proc far

arg_2= word ptr	 6

; FUNCTION CHUNK AT 056A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 057F SIZE 0000000B BYTES

push	bp
mov	bp, sp
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jb	short loc_880
mov	ax, 900h
stc
jmp	short loc_88B

loc_880:
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
jb	short loc_88B
mov	byte ptr [bx+0C2h], 0

loc_88B:
jmp	loc_81A
sub_86E	endp



; Attributes: bp-based frame

sub_88E	proc near

var_4= word ptr	-4
var_2= word ptr	-2
arg_2= word ptr	 6
arg_4= word ptr	 8
arg_6= word ptr	 0Ah
arg_8= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 4
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jb	short loc_8A2
mov	ax, 900h
jmp	short loc_8CC

loc_8A2:
test	[bp+arg_6], 8000h
jz	short loc_8F1
cmp	[bp+arg_8], 0
jz	short loc_8C9
xor	cx, cx
mov	dx, cx
mov	ax, 4201h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from present location
jb	short loc_905
test	[bp+arg_8], 2
jnz	short loc_8CF
add	ax, [bp+arg_4]
adc	dx, [bp+arg_6]
jns	short loc_8F1

loc_8C9:
mov	ax, 1600h

loc_8CC:
stc
jmp	short loc_905

loc_8CF:
mov	[bp+var_2], dx
mov	[bp+var_4], ax
mov	dx, cx
mov	ax, 4202h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
add	ax, [bp+arg_4]
adc	dx, [bp+arg_6]
jns	short loc_8F1
mov	cx, [bp+var_2]
mov	dx, [bp+var_4]
mov	ax, 4200h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from beginning of	file
jmp	short loc_8C9

loc_8F1:
mov	dx, [bp+arg_4]
mov	cx, [bp+arg_6]
mov	al, byte ptr [bp+arg_8]
mov	ah, 42h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method:
			; 0-from beginnig,1-from current,2-from	end
jb	short loc_905
and	byte ptr [bx+0C2h], 0FDh

loc_905:
jmp	loc_82D
sub_88E	endp



; Attributes: bp-based frame

sub_908	proc far

var_4= byte ptr	-4
var_3= byte ptr	-3
var_2= byte ptr	-2
var_1= byte ptr	-1
arg_0= dword ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

; FUNCTION CHUNK AT 057D SIZE 00000002 BYTES

push	bp
mov	bp, sp
sub	sp, 4
xor	bh, bh

loc_910:
mov	[bp+var_2], bh
mov	ax, [bp+arg_4]
mov	cx, ax
mov	[bp+var_4], 0
test	ax, 8000h
jnz	short loc_931
test	ax, 4000h
jnz	short loc_92D
test	byte_1EB1, 80h
jnz	short loc_931

loc_92D:
mov	[bp+var_4], 80h	; ''

loc_931:
push	ds
lds	dx, [bp+arg_0]
and	al, 3
or	al, bh
mov	ah, 3Dh
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read, 1 -	write, 2 - read	& write
pop	ds
jnb	short loc_952
cmp	ax, 2
jnz	short loc_94E
test	cx, 100h
jz	short loc_94E
jmp	loc_9F1

loc_94E:
stc
jmp	loc_82D

loc_952:
xchg	ax, bx
mov	ax, cx
and	ax, 500h
cmp	ax, 500h
jnz	short loc_966
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
mov	ax, 1100h
jmp	short loc_94E

loc_966:
mov	[bp+var_3], 1
mov	ax, 4400h
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
test	dl, 80h
jz	short loc_978
or	[bp+var_4], 40h

loc_978:
test	[bp+var_4], 40h
jz	short loc_981
jmp	loc_A5E

loc_981:
mov	ax, [bp+arg_4]
test	ax, 200h
jz	short loc_9A8
test	ax, 3
jz	short loc_997
xor	cx, cx
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
jmp	loc_A5E

loc_997:
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
push	ds
lds	dx, [bp+arg_0]
mov	ax, 4300h
int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name or directory
			; name without trailing	slash
pop	ds
jmp	short loc_A0E
align 2

loc_9A8:
test	[bp+var_4], 80h
jnz	short loc_9B1
jmp	loc_A5E

loc_9B1:
test	ax, 2
jnz	short loc_9B9
jmp	loc_A5E

loc_9B9:
mov	cx, 0FFFFh
mov	dx, cx
mov	ax, 4202h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
neg	cx
lea	dx, [bp-1]
mov	ah, 3Fh
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
or	ax, ax
jz	short loc_9E5
cmp	[bp+var_1], 1Ah
jnz	short loc_9E5
neg	cx
mov	dx, cx
mov	ax, 4202h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
xor	cx, cx
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

loc_9E5:
xor	cx, cx
mov	dx, cx
mov	ax, 4200h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from beginning of	file
jmp	short loc_A5E
db 90h

loc_9F1:
mov	[bp+var_3], 0
mov	cx, [bp+arg_6]
call	sub_AA7
mov	[bp+arg_6], cx
test	[bp+var_2], 0FFh
jnz	short loc_A0B
test	[bp+arg_4], 2
jnz	short loc_A0E

loc_A0B:
and	cl, 0FEh

loc_A0E:
push	ds
lds	dx, [bp+arg_0]
mov	ah, 3Ch
int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
pop	ds
jnb	short loc_A1C

loc_A19:
jmp	loc_82D

loc_A1C:
xchg	ax, bx
test	[bp+var_2], 0FFh
jnz	short loc_A2A
test	[bp+arg_4], 2
jnz	short loc_A5E

loc_A2A:
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
mov	al, byte ptr [bp+arg_4]
and	al, 3
or	al, [bp+var_2]
push	ds
lds	dx, [bp+arg_0]
mov	ah, 3Dh
int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read, 1 -	write, 2 - read	& write
pop	ds
jb	short loc_A19
xchg	ax, bx
test	[bp+var_3], 1
jnz	short loc_A5E
test	[bp+arg_6], 1
jz	short loc_A5E
or	cl, 1
push	ds
lds	dx, [bp+arg_0]
mov	ax, 4301h
int	21h		; DOS -	2+ - SET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name
			; CX = file attribute bits
pop	ds
jb	short loc_A19

loc_A5E:
test	[bp+var_4], 40h
jnz	short loc_AA3
push	ds
lds	dx, [bp+arg_0]
mov	ax, 4300h
int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name or directory
			; name without trailing	slash
pop	ds
mov	ax, cx
xor	cl, cl
and	ax, 1
jz	short loc_A79
mov	cl, 10h

loc_A79:
test	[bp+arg_4], 8
jz	short loc_A83
or	cl, 20h

loc_A83:
cmp	bx, word_1E60
jb	short loc_A93
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
mov	ax, 1800h
jmp	loc_94E

loc_A93:
or	cl, [bp+var_4]
or	cl, 1
mov	[bx+0C2h], cl
mov	ax, bx
mov	sp, bp
pop	bp
retf

loc_AA3:
xor	cl, cl
jmp	short loc_A83
sub_908	endp




sub_AA7	proc near
mov	ax, word_1E55
not	ax
and	ax, cx
xor	cx, cx
test	al, 80h
jnz	short locret_AB7
or	cl, 1

locret_AB7:
retn
sub_AA7	endp



; Attributes: bp-based frame

sub_AB8	proc far

var_1= word ptr	-1
arg_2= word ptr	 6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
sub	sp, 2
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jb	short loc_ACD
stc
mov	ax, 900h
jmp	short loc_B32

loc_ACD:
test	byte ptr [bx+0C2h], 2
jz	short loc_AD9
xor	ax, ax
jmp	loc_82D

loc_AD9:
mov	cx, [bp+arg_6]
push	ds
lds	dx, [bp+8]
mov	ah, 3Fh
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
pop	ds
jnb	short loc_AEB
mov	ah, 9
jmp	short loc_B32

loc_AEB:
test	byte ptr [bx+0C2h], 80h
jz	short loc_B32
and	byte ptr [bx+0C2h], 0FBh
push	si
push	di
push	ds
pop	es
assume es:dseg
mov	ds, [bp+arg_4]
cld
mov	si, dx
mov	di, dx
mov	cx, ax
jcxz	short loc_B2E
mov	ah, 0Dh
cmp	byte ptr [si], 0Ah
jnz	short loc_B14
or	byte ptr es:[bx+0C2h], 4

loc_B14:
lodsb
cmp	al, ah
jz	short loc_B35
cmp	al, 1Ah
jnz	short loc_B25
or	byte ptr es:[bx+0C2h], 2
jmp	short loc_B2A

loc_B25:
mov	[di], al
inc	di

loc_B28:
loop	loc_B14

loc_B2A:
mov	ax, di
sub	ax, dx

loc_B2E:
push	es
pop	ds

loc_B30:
pop	di
pop	si

loc_B32:
jmp	loc_82D

loc_B35:
cmp	cx, 1
jz	short loc_B41
cmp	byte ptr [si], 0Ah
jz	short loc_B28
jmp	short loc_B25

loc_B41:
push	es
pop	ds
test	byte ptr [bx+0C2h], 40h
jz	short loc_B62
mov	ax, 4400h
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
test	dx, 20h
jnz	short loc_B5E
lea	dx, [bp-1]
mov	ah, 3Fh
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
jb	short loc_B30

loc_B5E:
mov	al, 0Ah
jmp	short loc_B8E

loc_B62:
mov	byte ptr [bp+var_1], 0
lea	dx, [bp+var_1]
mov	ah, 3Fh
int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
jb	short loc_B30
or	ax, ax
jz	short loc_B8C
cmp	[bp+arg_6], 1
jz	short loc_B98

loc_B79:
mov	cx, 0FFFFh
mov	dx, cx
mov	ax, 4201h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from present location
mov	cx, 1
cmp	byte ptr [bp+var_1], 0Ah
jz	short loc_B93

loc_B8C:
mov	al, 0Dh

loc_B8E:
lds	dx, [bp+8]
jmp	short loc_B25

loc_B93:
lds	dx, [bp+8]
jmp	short loc_B28

loc_B98:
cmp	byte ptr [bp+var_1], 0Ah
jnz	short loc_B79
jmp	short loc_B5E
sub_AB8	endp



; Attributes: bp-based frame

sub_BA0	proc far

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_2= word ptr	 6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

; FUNCTION CHUNK AT 0A00 SIZE 00000039 BYTES

push	bp
mov	bp, sp
sub	sp, 8
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jb	short loc_BB6
mov	ax, 900h
stc

loc_BB3:
jmp	loc_82D

loc_BB6:
test	byte ptr [bx+0C2h], 20h
jz	short loc_BC8
mov	ax, 4202h
xor	cx, cx
mov	dx, cx
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
jb	short loc_BB3

loc_BC8:
test	byte ptr [bx+0C2h], 80h
jz	short loc_C4B
mov	[bp+var_6], ds
mov	es, [bp+arg_4]
assume es:nothing
lds	dx, [bp+8]
xor	ax, ax
mov	[bp+var_2], ax
mov	[bp+var_4], ax
cld
push	di
push	si
mov	di, dx
mov	si, dx
mov	[bp+var_8], sp
mov	cx, [bp+arg_6]
jcxz	short loc_C4D
mov	al, 0Ah
repne scasb
jnz	short loc_C46
push	ds
mov	ds, [bp+var_6]
call	sub_CEA
pop	ds
cmp	ax, 0A8h ; 'จ'
jbe	short loc_C4F
sub	sp, 2
mov	bx, sp
mov	dx, 200h
cmp	ax, 228h
jnb	short loc_C14
mov	dx, 80h	; ''

loc_C14:
sub	sp, dx
mov	dx, sp
mov	di, dx
push	ss
pop	es
assume es:dseg
mov	cx, [bp+arg_6]

loc_C1F:
lodsb
cmp	al, 0Ah
jz	short loc_C30

loc_C24:
cmp	di, bx
jz	short loc_C41

loc_C28:
stosb
loop	loc_C1F
call	near ptr sub_C54
jmp	short loc_C9F

loc_C30:
mov	al, 0Dh
cmp	di, bx
jnz	short loc_C39
call	near ptr sub_C54

loc_C39:
stosb
mov	al, 0Ah
inc	[bp+var_4]
jmp	short loc_C24

loc_C41:
call	near ptr sub_C54
jmp	short loc_C28

loc_C46:
pop	si
pop	di
mov	ds, [bp+var_6]

loc_C4B:
jmp	short loc_CB0

loc_C4D:
jmp	short loc_C9F

loc_C4F:
xor	ax, ax
jmp	loc_37C
sub_BA0	endp




sub_C54	proc far
push	ax
push	bx
push	cx
push	ds
push	es
pop	ds
mov	cx, di
sub	cx, dx
jcxz	short loc_C70
mov	bx, [bp+6]
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
jb	short loc_C77
add	[bp-2],	ax
or	ax, ax
jz	short loc_C77

loc_C70:
pop	ds
pop	cx
pop	bx
pop	ax
mov	di, dx
retn

loc_C77:
pop	ds
add	sp, 8
jnb	short loc_C81
mov	ah, 9
jmp	short loc_CA5

loc_C81:
mov	ds, word ptr [bp-2]
test	byte ptr [bx+0C2h], 40h
jz	short loc_C99
mov	ds, word ptr [bp+0Ah]
mov	bx, [bp+8]
cmp	byte ptr [bx], 1Ah
jnz	short loc_C99
clc
jmp	short loc_CA5

loc_C99:
stc
mov	ax, 1C00h
jmp	short loc_CA5

loc_C9F:
mov	ax, [bp-2]
sub	ax, [bp-4]

loc_CA5:
mov	sp, [bp-8]
pop	si
pop	di
mov	ds, word ptr [bp-6]

loc_CAD:
jmp	loc_82D
sub_C54	endp

; START	OF FUNCTION CHUNK FOR sub_BA0

loc_CB0:
mov	cx, [bp+arg_6]
or	cx, cx
jnz	short loc_CBC
mov	ax, cx
jmp	loc_82D

loc_CBC:
push	ds
lds	dx, [bp+8]
mov	ah, 40h
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
push	ds
pop	es
pop	ds
jnb	short loc_CCD
mov	ah, 9
jmp	short loc_CAD

loc_CCD:
or	ax, ax
jnz	short loc_CAD
test	byte ptr [bx+0C2h], 40h
jz	short loc_CE3
mov	bx, dx
cmp	byte ptr es:[bx], 1Ah
jnz	short loc_CE3
clc
jmp	short loc_CAD

loc_CE3:
stc
mov	ax, 1C00h
jmp	short loc_CAD
; END OF FUNCTION CHUNK	FOR sub_BA0
align 2



sub_CEA	proc far
pop	cx
pop	dx
mov	ax, word_1E96
cmp	ax, sp
jnb	short loc_CFA
sub	ax, sp
neg	ax

loc_CF7:
push	dx
push	cx
retf

loc_CFA:
xor	ax, ax
jmp	short loc_CF7
sub_CEA	endp



; Attributes: bp-based frame

sub_CFE	proc far
push	bp
mov	bp, sp
mov	ax, 0Ah
push	ax
call	sub_7AD
mov	ax, 16h
push	ax
call	sub_124A
mov	ax, 3
push	ax
call	far ptr	sub_46B
mov	sp, bp
pop	bp
retf
sub_CFE	endp



; Attributes: bp-based frame

sub_D20	proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	bx, [bp+arg_0]
cmp	bx, word_1E60
jge	short loc_D3D
cmp	bx, 0
jl	short loc_D3D
test	byte ptr [bx+0C2h], 40h
jz	short loc_D3D
mov	ax, 1
jmp	short loc_D3F

loc_D3D:
xor	ax, ax

loc_D3F:
mov	sp, bp
pop	bp
retf
sub_D20	endp

align 2


; Attributes: bp-based frame

sub_D44	proc far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	[bp+arg_4]
mov	ax, 302h
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
call	sub_908
add	sp, 8
mov	sp, bp
pop	bp
retf
sub_D44	endp



; Attributes: bp-based frame

sub_D60	proc far

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 8
push	[bp+arg_0]
call	sub_FE2
add	sp, 2
mov	[bp+var_8], ax
mov	[bp+var_6], dx
cmp	ax, 0FFFFh
jnz	short loc_D81
cmp	dx, 0FFFFh
jz	short loc_D9C

loc_D81:
push	[bp+arg_0]
call	sub_DDE
add	sp, 2
mov	[bp+var_4], ax
mov	[bp+var_2], dx
cmp	ax, 0FFFFh
jnz	short loc_DA4
cmp	dx, 0FFFFh
jnz	short loc_DA4

loc_D9C:
mov	ax, 0FFFFh
mov	sp, bp
pop	bp
retf
align 2

loc_DA4:
mov	ax, [bp+var_8]
mov	dx, [bp+var_6]
cmp	[bp+var_4], ax
jnz	short loc_DBC
cmp	[bp+var_2], dx
jnz	short loc_DBC
mov	ax, 1
mov	sp, bp
pop	bp
retf
align 2

loc_DBC:
sub	ax, ax
mov	sp, bp
pop	bp
retf
sub_D60	endp



; Attributes: bp-based frame

sub_DC2	proc far

arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 0Eh
xor	bh, bh
cmp	byte ptr word_1E5B, 3
jb	short loc_DD4
mov	bh, byte ptr [bp+arg_6]

loc_DD4:
mov	ax, [bp+arg_8]
mov	[bp+arg_6], ax
jmp	loc_910
sub_DC2	endp

align 2


; Attributes: bp-based frame

sub_DDE	proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, 1
push	ax
sub	ax, ax
push	ax
push	ax
push	[bp+arg_0]
call	far ptr	sub_88E
add	sp, 8
pop	bp
retf
sub_DDE	endp



; Attributes: bp-based frame

sub_DF6	proc far

var_226= word ptr -226h
var_224= word ptr -224h
var_222= word ptr -222h
var_22=	word ptr -22h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_12=	word ptr -12h
var_10=	word ptr -10h
var_E= word ptr	-0Eh
var_C= word ptr	-0Ch
var_A= word ptr	-0Ah
var_8= word ptr	-8
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
mov	ax, 226h
call	sub_51C
push	di
push	si
mov	si, [bp+arg_0]
lea	ax, [bp+var_222]
mov	[bp+var_226], ax
mov	[bp+var_224], ss
mov	ax, 1
push	ax
sub	ax, ax
push	ax
push	ax
push	si
call	far ptr	sub_88E
add	sp, 8
mov	[bp+var_1E], ax
mov	[bp+var_1C], dx
cmp	ax, 0FFFFh
jnz	short loc_E36
cmp	dx, 0FFFFh
jnz	short loc_E36
jmp	loc_F6E

loc_E36:
mov	ax, 2
push	ax
sub	ax, ax
push	ax
push	ax
push	si
call	far ptr	sub_88E
add	sp, 8
mov	cx, [bp+arg_2]
mov	bx, [bp+arg_4]
sub	cx, ax
sbb	bx, dx
mov	[bp+var_22], cx
mov	[bp+var_20], bx
or	bx, bx
jge	short loc_E5E
jmp	loc_F12

loc_E5E:
jg	short loc_E67
or	cx, cx
jnz	short loc_E67
jmp	loc_F12

loc_E67:
mov	ax, 200h
push	ax
sub	ax, ax
push	ax
push	[bp+var_224]
push	[bp+var_226]
call	sub_11F6
add	sp, 8
mov	al, [si+0C2h]
cbw
mov	[bp+var_10], ax
and	al, 7Fh
mov	[si+0C2h], al
mov	di, [bp+var_1A]

loc_E8F:
cmp	[bp+var_20], 0
jl	short loc_EA4
jg	short loc_E9E
cmp	[bp+var_22], 200h
jb	short loc_EA4

loc_E9E:
mov	ax, 200h
jmp	short loc_EA7
align 2

loc_EA4:
mov	ax, [bp+var_22]

loc_EA7:
mov	di, ax
cwd
sub	[bp+var_22], ax
sbb	[bp+var_20], dx
push	di
push	[bp+var_224]
push	[bp+var_226]
push	si
call	sub_BA0
add	sp, 8
mov	di, ax
inc	ax
jnz	short loc_EE6
mov	al, byte ptr [bp+var_10]
mov	[si+0C2h], al
cmp	word_1E5E, 5
jnz	short loc_EDB
mov	word_1E53, 0Dh

loc_EDB:
mov	ax, di
mov	[bp+var_1A], di
pop	si
pop	di
mov	sp, bp
pop	bp
retf

loc_EE6:
mov	ax, [bp+var_22]
or	ax, [bp+var_20]
jnz	short loc_E8F
mov	[bp+var_1A], di
mov	al, byte ptr [bp+var_10]
mov	[si+0C2h], al
sub	ax, ax
push	ax
push	[bp+var_1C]
push	[bp+var_1E]
push	si
call	far ptr	sub_88E
add	sp, 8
sub	ax, ax
pop	si
pop	di
mov	sp, bp
pop	bp
retf

loc_F12:
sub	ax, ax
push	ax
push	[bp+arg_4]
push	[bp+arg_2]
push	si
call	far ptr	sub_88E
add	sp, 8
mov	[bp+var_E], 4000h
mov	[bp+var_C], si
mov	[bp+var_A], 0
mov	ax, [bp+var_224]
mov	[bp+var_12], ax
mov	ax, [bp+var_226]
mov	[bp+var_8], ax
lea	ax, [bp+var_18]
push	ss
push	ax
lea	ax, [bp+var_E]
push	ss
push	ax
lea	ax, [bp+var_E]
push	ss
push	ax
call	sub_1194
add	sp, 0Ch
sub	ax, ax
push	ax
push	[bp+var_1C]
push	[bp+var_1E]
push	si
call	far ptr	sub_88E
add	sp, 8
cmp	[bp+var_2], 0
jz	short loc_F78

loc_F6E:
mov	ax, 0FFFFh
pop	si
pop	di
mov	sp, bp
pop	bp
retf
align 2

loc_F78:
mov	ax, [bp+var_E]
pop	si
pop	di
mov	sp, bp
pop	bp
retf
sub_DF6	endp

align 2


; Attributes: bp-based frame

sub_F82	proc far

arg_2= word ptr	 6

push	bp
mov	bp, sp
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jb	short loc_F94

loc_F8E:
mov	ax, 900h
stc
jmp	short loc_FB7

loc_F94:
mov	ah, 45h
int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
			; BX = file handle to duplicate
jb	short loc_FB7
cmp	ax, word_1E60
jb	short loc_FAC
mov	bx, ax
mov	ah, 3Eh
int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
mov	ax, 1800h
stc
jmp	short loc_FB7

loc_FAC:
mov	cl, [bx+0C2h]
mov	bx, ax
mov	[bx+0C2h], cl
clc

loc_FB7:
jmp	loc_82D
sub_F82	endp



; Attributes: bp-based frame

sub_FBA	proc far

arg_2= word ptr	 6
arg_4= word ptr	 8

push	bp
mov	bp, sp
mov	bx, [bp+arg_2]
cmp	bx, word_1E60
jnb	short loc_F8E
mov	cx, [bp+arg_4]
cmp	cx, word_1E60
jnb	short loc_F8E
mov	ah, 46h
int	21h		; DOS -	2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)
			; BX = existing	file handle, CX	= new file handle
jb	short loc_FDF
mov	dl, [bx+0C2h]
mov	bx, cx
mov	[bx+0C2h], dl

loc_FDF:
jmp	loc_81A
sub_FBA	endp



; Attributes: bp-based frame

sub_FE2	proc far

var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 8
push	si
mov	si, [bp+arg_0]
mov	ax, 1
push	ax
sub	ax, ax
push	ax
push	ax
push	si
call	far ptr	sub_88E
add	sp, 8
mov	[bp+var_8], ax
mov	[bp+var_6], dx
cmp	ax, 0FFFFh
jnz	short loc_1016
cmp	dx, 0FFFFh
jnz	short loc_1016
mov	ax, 0FFFFh
cwd
pop	si
mov	sp, bp
pop	bp
retf

loc_1016:
mov	ax, 2
push	ax
sub	ax, ax
push	ax
push	ax
push	si
call	far ptr	sub_88E
add	sp, 8
mov	[bp+var_4], ax
mov	[bp+var_2], dx
sub	ax, ax
push	ax
push	[bp+var_6]
push	[bp+var_8]
push	si
call	far ptr	sub_88E
add	sp, 8
mov	ax, [bp+var_4]
mov	dx, [bp+var_2]
pop	si
mov	sp, bp
pop	bp
retf
sub_FE2	endp



; Attributes: bp-based frame

sub_104A proc far

var_C= word ptr	-0Ch
var_A= dword ptr -0Ah
var_6= word ptr	-6
var_4= word ptr	-4
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 0Ch
push	di
push	si
mov	ax, [bp+arg_0]
mov	dx, [bp+arg_2]
mov	word ptr [bp+var_A], ax
mov	word ptr [bp+var_A+2], dx
mov	si, 61h	; 'a'
mov	[bp+var_4], 0
call	sub_14AA
mov	[bp+var_C], ax
les	di, [bp+var_A]
assume es:nothing
jmp	short loc_1075
align 2

loc_1074:
inc	di

loc_1075:
cmp	byte ptr es:[di], 0
jnz	short loc_1074
mov	word ptr [bp+var_A], di
mov	word ptr [bp+var_A+2], es
mov	di, [bp+var_C]
jmp	short loc_10A3

loc_1086:
inc	[bp+var_4]
mov	ax, di
sub	dx, dx
mov	cx, 0Ah
div	cx
add	dl, 30h	; '0'
mov	bx, word ptr [bp+var_A]
mov	es:[bx], dl
mov	ax, di
sub	dx, dx
div	cx
mov	di, ax

loc_10A3:
dec	word ptr [bp+var_A]
mov	bx, word ptr [bp+var_A]
cmp	byte ptr es:[bx], 58h ;	'X'
jz	short loc_1086
mov	[bp+var_C], di
inc	word ptr [bp+var_A]
mov	bx, word ptr [bp+var_A]
cmp	byte ptr es:[bx], 0
jz	short loc_10C4
cmp	[bp+var_4], 6
jz	short loc_10CE

loc_10C4:
sub	ax, ax
cwd
pop	si
pop	di
mov	sp, bp
pop	bp
retf
align 2

loc_10CE:
mov	ax, word_1E53
mov	[bp+var_6], ax
mov	word_1E53, 0
mov	di, ax

loc_10DC:
sub	ax, ax
push	ax
push	[bp+arg_2]
push	[bp+arg_0]
call	sub_1460
add	sp, 6
or	ax, ax
jz	short loc_10F8
cmp	word_1E53, 0Dh
jnz	short loc_1116

loc_10F8:
mov	word_1E53, 0
cmp	si, 7Bh	; '{'
jnz	short loc_110A
mov	word_1E53, di
jmp	short loc_10C4
align 2

loc_110A:
les	bx, [bp+var_A]
mov	ax, si
mov	es:[bx], al
inc	si
jmp	short loc_10DC
align 2

loc_1116:
mov	ax, [bp+var_6]
mov	word_1E53, ax
mov	ax, [bp+arg_0]
mov	dx, [bp+arg_2]
pop	si
pop	di
mov	sp, bp
pop	bp
retf
sub_104A endp



; Attributes: bp-based frame

sub_1128 proc far

var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 2
push	si
mov	si, [bp+arg_0]
or	si, si
jl	short loc_1143
cmp	word_1E60, si
jle	short loc_1143
test	byte ptr [si+0C2h], 1
jnz	short loc_1152

loc_1143:
mov	word_1E53, 9

loc_1149:
mov	ax, 0FFFFh
pop	si
mov	sp, bp
pop	bp
retf
align 2

loc_1152:
mov	al, [si+0C2h]
and	ax, 80h
mov	[bp+var_2], ax
cmp	[bp+arg_2], 8000h
jnz	short loc_116A
and	byte ptr [si+0C2h], 7Fh
jmp	short loc_1176

loc_116A:
cmp	[bp+arg_2], 4000h
jnz	short loc_1184
or	byte ptr [si+0C2h], 80h

loc_1176:
cmp	[bp+var_2], 0
jz	short loc_118C
mov	ax, 4000h
pop	si
mov	sp, bp
pop	bp
retf

loc_1184:
mov	word_1E53, 16h
jmp	short loc_1149

loc_118C:
mov	ax, 8000h
pop	si
mov	sp, bp
pop	bp
retf
sub_1128 endp



; Attributes: bp-based frame

sub_1194 proc far

arg_0= dword ptr  6
arg_4= dword ptr  0Ah
arg_8= dword ptr  0Eh

push	bp
mov	bp, sp
push	si
push	di
push	ds
lds	di, [bp+arg_0]
mov	ax, [di]
mov	bx, [di+2]
mov	cx, [di+4]
mov	dx, [di+6]
mov	si, [di+8]
push	word ptr [di+0Ah]
lds	di, [bp+arg_8]
mov	es, word ptr [di]
mov	ds, word ptr [di+6]
pop	di
int	21h		; DOS -
push	di
push	ds
lds	di, [bp+arg_8]
mov	word ptr [di], es
pop	word ptr [di+6]
lds	di, [bp+arg_4]
mov	[di], ax
mov	[di+2],	bx
mov	[di+4],	cx
mov	[di+6],	dx
mov	[di+8],	si
pop	word ptr [di+0Ah]
jb	short loc_11DD
xor	si, si
jmp	short loc_11EC

loc_11DD:
pop	ds
push	ds
call	sub_83A
lds	di, [bp+arg_4]
mov	si, 1
mov	ax, [di]

loc_11EC:
mov	[di+0Ch], si
pop	ds
pop	di
pop	si
mov	sp, bp
pop	bp
retf
sub_1194 endp



; Attributes: bp-based frame

sub_11F6 proc far

arg_0= dword ptr  6
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch

push	bp
mov	bp, sp
mov	cx, [bp+arg_6]
jcxz	short loc_1236
push	di
les	di, [bp+arg_0]
mov	dx, di
neg	dx
jz	short loc_1214
sub	dx, cx
sbb	bx, bx
and	dx, bx
add	dx, cx
xchg	dx, cx
sub	dx, cx

loc_1214:
mov	ax, [bp+arg_4]
mov	ah, al
shr	cx, 1
rep stosw
adc	cx, cx
rep stosb
xchg	dx, cx
jcxz	short loc_1235
mov	bx, es
add	bx, 1000h
mov	es, bx
assume es:nothing
shr	cx, 1
rep stosw
adc	cx, cx
rep stosb

loc_1235:
pop	di

loc_1236:
mov	ax, word ptr [bp+arg_0]
mov	dx, word ptr [bp+arg_0+2]
pop	bp
retf
sub_11F6 endp

off_123E dw offset loc_12D5
dw offset loc_12C6
dw offset loc_12BE
dw offset loc_12C6
dw offset loc_12C6
dw offset loc_12C6


; Attributes: bp-based frame

sub_124A proc far

var_4= dword ptr -4
arg_0= word ptr	 6

push	bp
mov	bp, sp
sub	sp, 4
mov	ax, [bp+arg_0]
cmp	ax, 2
jnz	short loc_1261
clc
int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
			; Return: return via RETF 2 with CF set
			; DOS will abort program with errorlevel 0
			; else
			; interrupted DOS call continues
jnb	short loc_12D5
mov	ah, 4Ch
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
			; AL = exit code

loc_1261:
cmp	ax, 8
jnz	short loc_1270
mov	bx, word ptr dword_1EF0
or	bx, word ptr dword_1EF0+2
jz	short loc_12CF

loc_1270:
call	sub_1385
jb	short loc_12CF
mov	ax, [bx]
mov	dx, [bx+2]
or	dx, dx
jnz	short loc_1292
cmp	ax, 1
ja	short loc_1292
or	ax, ax
jnz	short loc_12D5
mov	bx, cx
shl	bx, 1
jmp	cs:off_123E[bx]

loc_1292:
mov	word ptr [bp+var_4], ax
mov	word ptr [bp+var_4+2], dx
push	es
push	bp
push	di
push	si
mov	cx, [bp+arg_0]
cmp	cx, 8
jz	short loc_12AB
xor	ax, ax
mov	[bx], ax
mov	[bx+2],	ax

loc_12AB:
mov	ax, 8Ch	; ''
push	ax
push	cx
cld
call	[bp+var_4]
add	sp, 4
pop	si
pop	di
pop	bp
pop	es
assume es:nothing
jmp	short loc_12D5
align 2

loc_12BE:
mov	ax, 8Ch	; ''
call	ss:dword_1EF8

loc_12C6:
mov	ax, 3
push	ax
call	far ptr	sub_46B

loc_12CF:
mov	ax, 0FFFFh
jmp	short loc_12D7
db 90h

loc_12D5:
xor	ax, ax

loc_12D7:
mov	sp, bp
pop	bp
retf
sub_124A endp

align 2
db 2, 4, 8, 0Bh, 0Fh, 16h
push	bp
mov	bp, sp
sub	sp, 4
mov	ax, [bp+6]
cmp	ax, 8
jnz	short loc_1301
mov	bx, word ptr dword_1EF0
or	bx, word ptr dword_1EF0+2
jnz	short loc_1301

loc_12FA:
mov	ax, 1600h
stc
jmp	loc_82D

loc_1301:
call	sub_1385
jb	short loc_12FA
mov	ax, [bx]
mov	[bp-2],	ax
mov	ax, [bx+2]
mov	[bp-4],	ax
mov	ax, [bp+8]
mov	dx, [bp+0Ah]
mov	[bx], ax
mov	[bx+2],	dx
mov	cx, [bp+6]
cmp	cx, 2
jnz	short loc_1352
or	dx, dx
jnz	short loc_132E
or	ax, ax
jz	short loc_1352

loc_132E:
cmp	word_1EC6, 0
jnz	short loc_1352
push	bx
mov	al, 23h	; '#'
mov	ah, 35h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	word_1EC6, es
mov	word_1EC8, bx
pop	bx
mov	dx, 10FDh
push	ds
push	cs
pop	ds
assume ds:seg001
mov	al, 23h	; '#'
mov	ah, 25h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
assume ds:dseg

loc_1352:
cmp	cx, 8
jnz	short loc_137B
mov	ax, 1181h
mov	dx, [bx+2]
or	dx, dx
jnz	short loc_1372
mov	cx, [bx]
cmp	cx, 2
jnb	short loc_1372
mov	ax, 117Ch
or	cx, cx
jz	short loc_1372
mov	ax, 117Bh

loc_1372:
mov	dx, cs
mov	bx, 3
call	dword_1EF0

loc_137B:
mov	ax, [bp-2]
mov	dx, [bp-4]
mov	sp, bp
pop	bp
retf


; Attributes: bp-based frame

sub_1385 proc far
push	bp
mov	bp, sp
lea	bx, ds:1031h
mov	cx, 6

loc_138F:
cmp	cs:[bx], al
jz	short loc_139B
dec	bx
loop	loc_138F
stc
jmp	short loc_13A9
db 90h

loc_139B:
dec	cx
mov	ax, cx
shl	ax, 1
shl	ax, 1
lea	bx, word_1ECC
add	bx, ax
clc

loc_13A9:
mov	sp, bp
pop	bp
retf
sub_1385 endp

push	ax
lahf
push	ax
push	ds
push	dx
mov	ax, seg	dseg
mov	ds, ax
cmp	word_1E86, 0
jnz	short loc_13D2
mov	ax, word_1ECC
mov	dx, word_1ECE
or	dx, dx
jnz	short loc_13FF
cmp	ax, 1
ja	short loc_13FF
or	ax, ax
jnz	short loc_1424

loc_13D2:
sub	sp, 4
push	bp
mov	bp, sp
add	bp, 2
mov	al, 4

loc_13DD:
mov	dx, [bp+4]
mov	[bp+0],	dx
inc	bp
inc	bp
dec	al
cmp	al, 0
jnz	short loc_13DD
mov	ax, word_1EC8
mov	[bp+0],	ax
mov	ax, word_1EC6
mov	[bp+2],	ax
pop	bp
pop	dx
pop	ds
pop	ax
sahf
pop	ax
stc
retf

loc_13FF:
mov	word ptr dword_1EE4, ax
mov	word ptr dword_1EE4+2, dx
push	es
push	bp
push	di
push	si
push	cx
push	bx
xor	ax, ax
mov	word_1ECC, ax
mov	word_1ECE, ax
mov	ax, 2
push	ax
cld
call	dword_1EE4
pop	ax
pop	bx
pop	cx
pop	si
pop	di
pop	bp
pop	es

loc_1424:
pop	dx
pop	ds
pop	ax
sahf
pop	ax
clc
retf
retf
jmp	ss:dword_1EF8
push	bx
push	cx
push	dx
push	es
xor	ah, ah
push	ax
mov	ax, 8
push	ax
call	sub_1385
push	ss
pop	ds
call	dword ptr [bx]
add	sp, 4
pop	es
pop	dx
pop	cx
pop	bx
retf
align 2


; Attributes: bp-based frame

sub_144E proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	ax, [bp+arg_0]
and	ax, 180h
xchg	ax, word_1E55
mov	sp, bp
pop	bp
retf
sub_144E endp

align 2


; Attributes: bp-based frame

sub_1460 proc far

arg_2= dword ptr  6
arg_6= byte ptr	 0Ah

push	bp
mov	bp, sp
push	ds
lds	dx, [bp+arg_2]
mov	ax, 4300h
int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name or directory
			; name without trailing	slash
pop	ds
jb	short loc_147E
test	[bp+arg_6], 2
jz	short loc_147E
test	cl, 1
jz	short loc_147E
mov	ax, 0D00h
stc

loc_147E:
jmp	loc_81A
sub_1460 endp

align 2


; Attributes: bp-based frame

sub_1482 proc far

arg_2= dword ptr  6
arg_6= byte ptr	 0Ah

push	bp
mov	bp, sp
mov	bl, [bp+arg_6]
push	ds
lds	dx, [bp+arg_2]
mov	ax, 4300h
int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name or directory
			; name without trailing	slash
jb	short loc_14A5
test	bl, 80h
jz	short loc_149D
and	cl, 0FEh
jmp	short loc_14A0

loc_149D:
or	cl, 1

loc_14A0:
mov	ax, 4301h
int	21h		; DOS -	2+ - SET FILE ATTRIBUTES
			; DS:DX	-> ASCIZ file name
			; CX = file attribute bits

loc_14A5:
pop	ds
jmp	loc_81A
sub_1482 endp

align 2



sub_14AA proc far
mov	ax, word_1EE8
or	ax, ax
jnz	short locret_14CA
cmp	byte ptr word_1E5B, 4
jnz	short loc_14C1
mov	ax, 8700h
int	21h		; DOS -
or	al, al
jnz	short loc_14C7

loc_14C1:
mov	ah, 2Ch
int	21h		; DOS -	GET CURRENT TIME
			; Return: CH = hours, CL = minutes, DH = seconds
			; DL = hundredths of seconds
mov	ax, dx

loc_14C7:
mov	word_1EE8, ax

locret_14CA:
retf
sub_14AA endp

align 2


; Attributes: bp-based frame

sub_14CC proc far

arg_2= word ptr	 6
arg_4= word ptr	 8
arg_6= word ptr	 0Ah
arg_8= word ptr	 0Ch

push	bp
mov	bp, sp
push	si
push	di
mov	byte_1EEA, 0Ah
mov	bx, [bp+arg_2]
xor	cx, cx
mov	dx, cx
mov	ax, 4201h
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from present location
jnb	short loc_14E7
jmp	short loc_150C
db 90h

loc_14E7:
mov	cx, dx
mov	dx, ax
mov	di, [bp+arg_6]
mov	si, [bp+arg_8]
mov	ax, 5C00h
cmp	[bp+arg_4], 0
jnz	short loc_14FC
mov	al, 1

loc_14FC:		; DOS -	3+ - LOCK/UNLOCK FILE ACCESS
int	21h		; AL = 00h lock	/ 01h unlock
			; BX = file handle, CX:DX = starting offset of region to lock
			; SI:DI	= size of region to lock
jnb	short loc_156C
cmp	ax, 1
jz	short loc_150C
test	[bp+arg_4], 1
jnz	short loc_1510

loc_150C:
stc
jmp	short loc_156C
align 2

loc_1510:
cmp	byte_1EEA, 0
jnz	short loc_151B
mov	ah, 24h	; '$'
jmp	short loc_150C

loc_151B:
dec	byte_1EEA
push	cx
push	dx
mov	ah, 2Ch
int	21h		; DOS -	GET CURRENT TIME
			; Return: CH = hours, CL = minutes, DH = seconds
			; DL = hundredths of seconds
mov	al, dh
cbw
mov	bx, 64h	; 'd'
imul	bx
xor	dh, dh
add	ax, dx
mov	byte_1EEB, cl
mov	word_1EEC, ax

loc_1538:
mov	ah, 2Ch
int	21h		; DOS -	GET CURRENT TIME
			; Return: CH = hours, CL = minutes, DH = seconds
			; DL = hundredths of seconds
mov	al, dh
cbw
mov	bx, 64h	; 'd'
imul	bx
xor	dh, dh
add	ax, dx
cmp	cl, byte_1EEB
jz	short loc_1551
add	ax, 1770h

loc_1551:
sub	ax, word_1EEC
cmp	ax, 64h	; 'd'
jl	short loc_1538
pop	dx
pop	cx
mov	di, [bp+arg_6]
mov	si, [bp+arg_8]
mov	bx, [bp+arg_2]
mov	ax, 5C00h
int	21h		; DOS -	3+ - LOCK/UNLOCK FILE ACCESS
			; AL = 00h lock	/ 01h unlock
			; BX = file handle, CX:DX = starting offset of region to lock
			; SI:DI	= size of region to lock
jb	short loc_1510

loc_156C:
pop	di
pop	si
jmp	loc_81A
sub_14CC endp

align 2


; Attributes: bp-based frame

sub_1572 proc far

arg_2= dword ptr  6
arg_6= dword ptr  0Ah

push	bp
mov	bp, sp
push	di
push	ds
lds	dx, [bp+arg_2]
les	di, [bp+arg_6]
mov	ah, 56h
int	21h		; DOS -	2+ - RENAME A FILE
			; DS:DX	-> ASCIZ old name (drive and path allowed, no wildcards)
			; ES:DI	-> ASCIZ new name
pop	ds
pop	di
jmp	loc_81A
sub_1572 endp



; Attributes: bp-based frame

sub_1586 proc far

arg_2= dword ptr  6

push	bp
mov	bp, sp
push	ds
lds	dx, [bp+arg_2]
mov	ah, 41h
int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
pop	ds
jmp	loc_81A
sub_1586 endp

db 80Bh	dup(0)
seg001 ends


; Segment type:	Pure data
dseg segment para public 'DATA' use16
assume cs:dseg
db    0
db    0
word_1DA2 dw 0
align 8
db  4Dh	; M
db  53h	; S
db  20h
db  52h	; R
db  75h	; u
db  6Eh	; n
db  2Dh	; -
db  54h	; T
db  69h	; i
db  6Dh	; m
db  65h	; e
db  20h
db  4Ch	; L
db  69h	; i
db  62h	; b
db  72h	; r
db  61h	; a
db  72h	; r
db  79h	; y
db  20h
db  2Dh	; -
db  20h
db  43h	; C
db  6Fh	; o
db  70h	; p
db  79h	; y
db  72h	; r
db  69h	; i
db  67h	; g
db  68h	; h
db  74h	; t
db  20h
db  28h	; (
db  63h	; c
db  29h	; )
db  20h
word_1DCC dw 3931h
db  38h	; 8
db  37h	; 7
db  2Ch	; ,
db  20h
db  4Dh	; M
db  69h	; i
db  63h	; c
db  72h	; r
db  6Fh	; o
db  73h	; s
db  6Fh	; o
db  66h	; f
db  74h	; t
db  20h
db  43h	; C
db  6Fh	; o
db  72h	; r
db  70h	; p
db  1Eh
db    0
word_1DE2 dw 0
word_1DE4 dw 0
off_1DE6 dw offset sub_46B
word_1DE8 dw 0
dw seg dseg
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  48h	; H
db    0
db  3Bh	; ;
db  43h	; C
db  5Fh	; _
db  46h	; F
db  49h	; I
db  4Ch	; L
db  45h	; E
db  5Fh	; _
db  49h	; I
db  4Eh	; N
db  46h	; F
db  4Fh	; O
db    0
dword_1E47 dd 0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_1E53 dw 0
word_1E55 dw 0
db    0
db    0
word_1E59 dw 0
word_1E5B dw 0
align 2
word_1E5E dw 0
word_1E60 dw 14h
db  81h	; 
db  81h	; 
db  81h	; 
db    1
db    1
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
word_1E76 dw 0
word_1E78 dw 0
word_1E7A dw 0
word_1E7C dw 0
word_1E7E dw 0
word_1E80 dw 0E4h
seg_1E82 dw seg	dseg
db  43h	; C
db    0
word_1E86 dw 0
byte_1E88 db 0
byte_1E89 db 0
dword_1E8A dd 0
unk_1E8E db    0
db    0
word_1E90 dw 0
dword_1E92 dd 0FFFFFFFFh
word_1E96 dw 3C0h
dword_1E98 dd 0
db    0
db  16h
db    2
db    2
db  18h
db  0Dh
db    9
db  0Ch
db  0Ch
db  0Ch
db    7
db    8
db  16h
db  16h
db 0FFh
db  12h
db  0Dh
db  12h
db    2
db 0FFh
db    0
byte_1EB1 db 0
dd loc_516
dd loc_516
dd loc_516
dd loc_516
dd loc_516
word_1EC6 dw 0
word_1EC8 dw 0
db    1
db    1
word_1ECC dw 0
word_1ECE dw 0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
dword_1EE4 dd 0
word_1EE8 dw 0
byte_1EEA db 0
byte_1EEB db 0
word_1EEC dw 0
align 4
dword_1EF0 dd 0
dword_1EF4 dd 0
dword_1EF8 dd 0
aDummy_txt db 'dummy.txt',0
aDummy_txt_0 db	'dummy.txt',0
aNewfile_txt db	'newfile.txt',0
aSomefile_txt db 'somefile.txt',0
align 2
aNewname_txt db	'newname.txt',0
aOldname_txt db	'oldname.txt',0
aSharedfile_txt	db 'sharedfile.txt',0
align 2
aNmsg db '<<NMSG>>',0
align 2
aR6000StackOver	db 'R6000',0Dh,0Ah
db '- stack overflow',0Dh,0Ah,0
db    3
db    0
db  52h	; R
db  36h	; 6
db  30h	; 0
db  30h	; 0
db  33h	; 3
db  0Dh
db  0Ah
db  2Dh	; -
db  20h
db  69h	; i
db  6Eh	; n
db  74h	; t
db  65h	; e
db  67h	; g
db  65h	; e
db  72h	; r
db  20h
db  64h	; d
db  69h	; i
db  76h	; v
db  69h	; i
db  64h	; d
db  65h	; e
db  20h
db  62h	; b
db  79h	; y
db  20h
db  30h	; 0
db  0Dh
db  0Ah
db    0
db    9
db    0
db  52h	; R
db  36h	; 6
db  30h	; 0
db  30h	; 0
db  39h	; 9
db  0Dh
db  0Ah
db  2Dh	; -
db  20h
db  6Eh	; n
db  6Fh	; o
db  74h	; t
db  20h
db  65h	; e
db  6Eh	; n
db  6Fh	; o
db  75h	; u
db  67h	; g
db  68h	; h
db  20h
db  73h	; s
db  70h	; p
db  61h	; a
db  63h	; c
db  65h	; e
db  20h
db  66h	; f
db  6Fh	; o
db  72h	; r
db  20h
db  65h	; e
db  6Eh	; n
db  76h	; v
db  69h	; i
db  72h	; r
db  6Fh	; o
db  6Eh	; n
db  6Dh	; m
db  65h	; e
db  6Eh	; n
db  74h	; t
db  0Dh
db  0Ah
db    0
db 0FCh	; 
db    0
db  0Dh
db  0Ah
db    0
db 0FFh
db    0
db  72h	; r
db  75h	; u
db  6Eh	; n
db  2Dh	; -
db  74h	; t
db  69h	; i
db  6Dh	; m
db  65h	; e
db  20h
db  65h	; e
db  72h	; r
db  72h	; r
db  6Fh	; o
db  72h	; r
db  20h
db    0
db    2
db    0
db  52h	; R
db  36h	; 6
db  30h	; 0
db  30h	; 0
db  32h	; 2
db  0Dh
db  0Ah
db  2Dh	; -
db  20h
db  66h	; f
db  6Ch	; l
db  6Fh	; o
db  61h	; a
db  74h	; t
db  69h	; i
db  6Eh	; n
db  67h	; g
db  20h
db  70h	; p
db  6Fh	; o
db  69h	; i
db  6Eh	; n
db  74h	; t
db  20h
db  6Eh	; n
db  6Fh	; o
db  74h	; t
db  20h
db  6Ch	; l
db  6Fh	; o
db  61h	; a
db  64h	; d
db  65h	; e
db  64h	; d
db  0Dh
db  0Ah
db    0
db    1
db    0
db  52h	; R
db  36h	; 6
db  30h	; 0
db  30h	; 0
db  31h	; 1
db  0Dh
db  0Ah
db  2Dh	; -
db  20h
db  6Eh	; n
db  75h	; u
db  6Ch	; l
db  6Ch	; l
db  20h
db  70h	; p
db  6Fh	; o
db  69h	; i
db  6Eh	; n
db  74h	; t
db  65h	; e
db  72h	; r
db  20h
db  61h	; a
db  73h	; s
db  73h	; s
db  69h	; i
db  67h	; g
db  6Eh	; n
db  6Dh	; m
db  65h	; e
db  6Eh	; n
db  74h	; t
db  0Dh
db  0Ah
db    0
db  0Ah
db    0
db  0Ah
db  41h	; A
db  62h	; b
db  6Eh	; n
db  6Fh	; o
db  72h	; r
db  6Dh	; m
db  61h	; a
db  6Ch	; l
db  20h
db  70h	; p
db  72h	; r
db  6Fh	; o
db  67h	; g
db  72h	; r
db  61h	; a
db  6Dh	; m
db  20h
db  74h	; t
db  65h	; e
db  72h	; r
db  6Dh	; m
db  69h	; i
db  6Eh	; n
db  61h	; a
db  74h	; t
db  69h	; i
db  6Fh	; o
db  6Eh	; n
db  0Ah
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db 0FFh
align 4
dseg ends


; Segment type:	Uninitialized
seg003 segment byte stack 'STACK' use16
assume cs:seg003
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
db 800h	dup(?)
seg003 ends


end start
